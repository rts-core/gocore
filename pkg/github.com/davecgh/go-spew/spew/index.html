<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>spew - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../../../lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="../../../../../lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.18.4";</script>
<script src="../../../../../lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="../../../../../index.html">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="../../../../../index.html">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="http://localhost:8080/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package spew
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/davecgh/go-spew/spew"</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package spew implements a deep pretty printer for Go data structures to aid in
debugging.
</p>
<p>
A quick overview of the additional features spew provides over the built-in
printing facilities for Go data types are as follows:
</p>
<pre>* Pointers are dereferenced and followed
* Circular data structures are detected and handled properly
* Custom Stringer/error interfaces are optionally invoked, including
  on unexported types
* Custom types which only implement the Stringer/error interfaces via
  a pointer receiver are optionally invoked when passing non-pointer
  variables
* Byte arrays and slices are dumped like the hexdump -C command which
  includes offsets, byte values in hex, and ASCII output (only when using
  Dump style)
</pre>
<p>
There are two different approaches spew allows for dumping Go data structures:
</p>
<pre>* Dump style which prints with newlines, customizable indentation,
  and additional debug information such as types and all pointer addresses
  used to indirect to the final value
* A custom Formatter interface that integrates cleanly with the standard fmt
  package and replaces %v, %+v, %#v, and %#+v to provide inline printing
  similar to the default %v while providing the additional functionality
  outlined above and passing unsupported format verbs such as %x and %q
  along to fmt
</pre>
<h3 id="hdr-Quick_Start">Quick Start</h3>
<p>
This section demonstrates how to quickly get started with spew.  See the
sections below for further details on formatting and configuration options.
</p>
<p>
To dump a variable with full newlines, indentation, type, and pointer
information use Dump, Fdump, or Sdump:
</p>
<pre>spew.Dump(myVar1, myVar2, ...)
spew.Fdump(someWriter, myVar1, myVar2, ...)
str := spew.Sdump(myVar1, myVar2, ...)
</pre>
<p>
Alternatively, if you would prefer to use format strings with a compacted inline
printing style, use the convenience wrappers Printf, Fprintf, etc with
%v (most compact), %+v (adds pointer addresses), %#v (adds types), or
%#+v (adds types and pointer addresses):
</p>
<pre>spew.Printf(&#34;myVar1: %v -- myVar2: %+v&#34;, myVar1, myVar2)
spew.Printf(&#34;myVar3: %#v -- myVar4: %#+v&#34;, myVar3, myVar4)
spew.Fprintf(someWriter, &#34;myVar1: %v -- myVar2: %+v&#34;, myVar1, myVar2)
spew.Fprintf(someWriter, &#34;myVar3: %#v -- myVar4: %#+v&#34;, myVar3, myVar4)
</pre>
<h3 id="hdr-Configuration_Options">Configuration Options</h3>
<p>
Configuration of spew is handled by fields in the ConfigState type.  For
convenience, all of the top-level functions use a global state available
via the spew.Config global.
</p>
<p>
It is also possible to create a ConfigState instance that provides methods
equivalent to the top-level functions.  This allows concurrent configuration
options.  See the ConfigState documentation for more details.
</p>
<p>
The following configuration options are available:
</p>
<pre>* Indent
	String to use for each indentation level for Dump functions.
	It is a single space by default.  A popular alternative is &#34;\t&#34;.

* MaxDepth
	Maximum number of levels to descend into nested data structures.
	There is no limit by default.

* DisableMethods
	Disables invocation of error and Stringer interface methods.
	Method invocation is enabled by default.

* DisablePointerMethods
	Disables invocation of error and Stringer interface methods on types
	which only accept pointer receivers from non-pointer variables.
	Pointer method invocation is enabled by default.

* DisablePointerAddresses
	DisablePointerAddresses specifies whether to disable the printing of
	pointer addresses. This is useful when diffing data structures in tests.

* DisableCapacities
	DisableCapacities specifies whether to disable the printing of
	capacities for arrays, slices, maps and channels. This is useful when
	diffing data structures in tests.

* ContinueOnMethod
	Enables recursion into types after invoking error and Stringer interface
	methods. Recursion after method invocation is disabled by default.

* SortKeys
	Specifies map keys should be sorted before being printed. Use
	this to have a more deterministic, diffable output.  Note that
	only native types (bool, int, uint, floats, uintptr and string)
	and types which implement error or Stringer interfaces are
	supported with other types sorted according to the
	reflect.Value.String() output which guarantees display
	stability.  Natural map order is used by default.

* SpewKeys
	Specifies that, as a last resort attempt, map keys should be
	spewed to strings and sorted by those strings.  This is only
	considered if SortKeys is true.
</pre>
<h3 id="hdr-Dump_Usage">Dump Usage</h3>
<p>
Simply call spew.Dump with a list of variables you want to dump:
</p>
<pre>spew.Dump(myVar1, myVar2, ...)
</pre>
<p>
You may also call spew.Fdump if you would prefer to output to an arbitrary
io.Writer.  For example, to dump to standard error:
</p>
<pre>spew.Fdump(os.Stderr, myVar1, myVar2, ...)
</pre>
<p>
A third option is to call spew.Sdump to get the formatted output as a string:
</p>
<pre>str := spew.Sdump(myVar1, myVar2, ...)
</pre>
<h3 id="hdr-Sample_Dump_Output">Sample Dump Output</h3>
<p>
See the Dump example for details on the setup of the types and variables being
shown here.
</p>
<pre>(main.Foo) {
 unexportedField: (*main.Bar)(0xf84002e210)({
  flag: (main.Flag) flagTwo,
  data: (uintptr) &lt;nil&gt;
 }),
 ExportedField: (map[interface {}]interface {}) (len=1) {
  (string) (len=3) &#34;one&#34;: (bool) true
 }
}
</pre>
<p>
Byte (and uint8) arrays and slices are displayed uniquely like the hexdump -C
command as shown.
</p>
<pre>([]uint8) (len=32 cap=32) {
 00000000  11 12 13 14 15 16 17 18  19 1a 1b 1c 1d 1e 1f 20  |............... |
 00000010  21 22 23 24 25 26 27 28  29 2a 2b 2c 2d 2e 2f 30  |!&#34;#$%&amp;&#39;()*+,-./0|
 00000020  31 32                                             |12|
}
</pre>
<h3 id="hdr-Custom_Formatter">Custom Formatter</h3>
<p>
Spew provides a custom formatter that implements the fmt.Formatter interface
so that it integrates cleanly with standard fmt package printing functions. The
formatter is useful for inline printing of smaller data types similar to the
standard %v format specifier.
</p>
<p>
The custom formatter only responds to the %v (most compact), %+v (adds pointer
addresses), %#v (adds types), or %#+v (adds types and pointer addresses) verb
combinations.  Any other verbs such as %x and %q will be sent to the the
standard fmt package for formatting.  In addition, the custom formatter ignores
the width and precision arguments (however they will still work on the format
specifiers not handled by the custom formatter).
</p>
<h3 id="hdr-Custom_Formatter_Usage">Custom Formatter Usage</h3>
<p>
The simplest way to make use of the spew custom formatter is to call one of the
convenience functions such as spew.Printf, spew.Println, or spew.Printf.  The
functions have syntax you are most likely already familiar with:
</p>
<pre>spew.Printf(&#34;myVar1: %v -- myVar2: %+v&#34;, myVar1, myVar2)
spew.Printf(&#34;myVar3: %#v -- myVar4: %#+v&#34;, myVar3, myVar4)
spew.Println(myVar, myVar2)
spew.Fprintf(os.Stderr, &#34;myVar1: %v -- myVar2: %+v&#34;, myVar1, myVar2)
spew.Fprintf(os.Stderr, &#34;myVar3: %#v -- myVar4: %#+v&#34;, myVar3, myVar4)
</pre>
<p>
See the Index for the full list convenience functions.
</p>
<h3 id="hdr-Sample_Formatter_Output">Sample Formatter Output</h3>
<p>
Double pointer to a uint8:
</p>
<pre>  %v: &lt;**&gt;5
 %+v: &lt;**&gt;(0xf8400420d0-&gt;0xf8400420c8)5
 %#v: (**uint8)5
%#+v: (**uint8)(0xf8400420d0-&gt;0xf8400420c8)5
</pre>
<p>
Pointer to circular struct with a uint8 field and a pointer to itself:
</p>
<pre>  %v: &lt;*&gt;{1 &lt;*&gt;&lt;shown&gt;}
 %+v: &lt;*&gt;(0xf84003e260){ui8:1 c:&lt;*&gt;(0xf84003e260)&lt;shown&gt;}
 %#v: (*main.circular){ui8:(uint8)1 c:(*main.circular)&lt;shown&gt;}
%#+v: (*main.circular)(0xf84003e260){ui8:(uint8)1 c:(*main.circular)(0xf84003e260)&lt;shown&gt;}
</pre>
<p>
See the Printf example for details on the setup of variables being shown
here.
</p>
<h3 id="hdr-Errors">Errors</h3>
<p>
Since it is possible for custom Stringer/error interfaces to panic, spew
detects them and handles them internally by printing the panic information
inline with the output.  Since spew is intended to provide deep pretty printing
capabilities on structures, it intentionally does not return any errors.
</p>

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="index.html#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="index.html#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="index.html#Dump">func Dump(a ...interface{})</a></dd>
			
				
				<dd><a href="index.html#Errorf">func Errorf(format string, a ...interface{}) (err error)</a></dd>
			
				
				<dd><a href="index.html#Fdump">func Fdump(w io.Writer, a ...interface{})</a></dd>
			
				
				<dd><a href="index.html#Fprint">func Fprint(w io.Writer, a ...interface{}) (n int, err error)</a></dd>
			
				
				<dd><a href="index.html#Fprintf">func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)</a></dd>
			
				
				<dd><a href="index.html#Fprintln">func Fprintln(w io.Writer, a ...interface{}) (n int, err error)</a></dd>
			
				
				<dd><a href="index.html#NewFormatter">func NewFormatter(v interface{}) fmt.Formatter</a></dd>
			
				
				<dd><a href="index.html#Print">func Print(a ...interface{}) (n int, err error)</a></dd>
			
				
				<dd><a href="index.html#Printf">func Printf(format string, a ...interface{}) (n int, err error)</a></dd>
			
				
				<dd><a href="index.html#Println">func Println(a ...interface{}) (n int, err error)</a></dd>
			
				
				<dd><a href="index.html#Sdump">func Sdump(a ...interface{}) string</a></dd>
			
				
				<dd><a href="index.html#Sprint">func Sprint(a ...interface{}) string</a></dd>
			
				
				<dd><a href="index.html#Sprintf">func Sprintf(format string, a ...interface{}) string</a></dd>
			
				
				<dd><a href="index.html#Sprintln">func Sprintln(a ...interface{}) string</a></dd>
			
			
				
				<dd><a href="index.html#ConfigState">type ConfigState</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#NewDefaultConfig">func NewDefaultConfig() *ConfigState</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ConfigState.Dump">func (c *ConfigState) Dump(a ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ConfigState.Errorf">func (c *ConfigState) Errorf(format string, a ...interface{}) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ConfigState.Fdump">func (c *ConfigState) Fdump(w io.Writer, a ...interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ConfigState.Fprint">func (c *ConfigState) Fprint(w io.Writer, a ...interface{}) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ConfigState.Fprintf">func (c *ConfigState) Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ConfigState.Fprintln">func (c *ConfigState) Fprintln(w io.Writer, a ...interface{}) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ConfigState.NewFormatter">func (c *ConfigState) NewFormatter(v interface{}) fmt.Formatter</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ConfigState.Print">func (c *ConfigState) Print(a ...interface{}) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ConfigState.Printf">func (c *ConfigState) Printf(format string, a ...interface{}) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ConfigState.Println">func (c *ConfigState) Println(a ...interface{}) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ConfigState.Sdump">func (c *ConfigState) Sdump(a ...interface{}) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ConfigState.Sprint">func (c *ConfigState) Sprint(a ...interface{}) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ConfigState.Sprintf">func (c *ConfigState) Sprintf(format string, a ...interface{}) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="index.html#ConfigState.Sprintln">func (c *ConfigState) Sprintln(a ...interface{}) string</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example_ConfigState">ConfigState</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_ConfigState_Dump">ConfigState.Dump</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_ConfigState_Printf">ConfigState.Printf</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Dump">Dump</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_Printf">Printf</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/bypass.go">bypass.go</a>
			
				<a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/common.go">common.go</a>
			
				<a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go">config.go</a>
			
				<a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/doc.go">doc.go</a>
			
				<a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/dump.go">dump.go</a>
			
				<a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/format.go">format.go</a>
			
				<a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/spew.go">spew.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				
				<pre>const (
    <span class="comment">// UnsafeDisabled is a build-time constant which specifies whether or</span>
    <span class="comment">// not access to the unsafe package is available.</span>
    <span id="UnsafeDisabled">UnsafeDisabled</span> = <a href="../../../../builtin/index.html#false">false</a>
)</pre>
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>
Config is the active configuration of the top-level functions.
The configuration can be changed by modifying the contents of spew.Config.
</p>

				<pre>var <span id="Config">Config</span> = <a href="index.html#ConfigState">ConfigState</a>{<a href="index.html#ConfigState.Indent">Indent</a>: &#34; &#34;}</pre>
			
		
		
			
			
			<h2 id="Dump">func <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/dump.go?s=13729:13756#L497">Dump</a>
				<a class="permalink" href="index.html#Dump">&#xb6;</a>
				
				
			</h2>
			<pre>func Dump(a ...interface{})</pre>
			<p>
Dump displays the passed parameters to standard out with newlines, customizable
indentation, and additional debug information such as complete types and all
pointer addresses used to indirect to the final value.  It provides the
following features over the built-in printing facilities provided by the fmt
package:
</p>
<pre>* Pointers are dereferenced and followed
* Circular data structures are detected and handled properly
* Custom Stringer/error interfaces are optionally invoked, including
  on unexported types
* Custom types which only implement the Stringer/error interfaces via
  a pointer receiver are optionally invoked when passing non-pointer
  variables
* Byte arrays and slices are dumped like the hexdump -C command which
  includes offsets, byte values in hex, and ASCII output
</pre>
<p>
The configuration options are controlled by an exported package global,
spew.Config.  See ConfigState for options documentation.
</p>
<p>
See Fdump if you would prefer dumping to an arbitrary io.Writer or Sdump to
get the formatted result as a string.
</p>

			<div id="example_Dump" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		<p>This example demonstrates how to use Dump to dump variables to stdout.
</p>
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// The following package level declarations are assumed for this example:</span>
<span class="comment">/*
    type Flag int

    const (
        flagOne Flag = iota
        flagTwo
    )

    var flagStrings = map[Flag]string{
        flagOne: &#34;flagOne&#34;,
        flagTwo: &#34;flagTwo&#34;,
    }

    func (f Flag) String() string {
        if s, ok := flagStrings[f]; ok {
            return s
        }
        return fmt.Sprintf(&#34;Unknown flag (%d)&#34;, int(f))
    }

    type Bar struct {
        data uintptr
    }

    type Foo struct {
        unexportedField Bar
        ExportedField   map[interface{}]interface{}
    }
*/</span>

<span class="comment">// Setup some sample data structures for the example.</span>
bar := Bar{uintptr(0)}
s1 := Foo{bar, map[interface{}]interface{}{&#34;one&#34;: true}}
f := Flag(5)
b := []byte{
    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
    0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
    0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,
    0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
    0x31, 0x32,
}

<span class="comment">// Dump!</span>
spew.Dump(s1, f, b)

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">(spew_test.Foo) {
 unexportedField: (spew_test.Bar) {
  data: (uintptr) &lt;nil&gt;
 },
 ExportedField: (map[interface {}]interface {}) (len=1) {
  (string) (len=3) &#34;one&#34;: (bool) true
 }
}
(spew_test.Flag) Unknown flag (5)
([]uint8) (len=34 cap=34) {
 00000000  11 12 13 14 15 16 17 18  19 1a 1b 1c 1d 1e 1f 20  |............... |
 00000010  21 22 23 24 25 26 27 28  29 2a 2b 2c 2d 2e 2f 30  |!&#34;#$%&amp;&#39;()*+,-./0|
 00000020  31 32                                             |12|
}
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Errorf">func <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/spew.go?s=1225:1281#L22">Errorf</a>
				<a class="permalink" href="index.html#Errorf">&#xb6;</a>
				
				
			</h2>
			<pre>func Errorf(format <a href="../../../../builtin/index.html#string">string</a>, a ...interface{}) (err <a href="../../../../builtin/index.html#error">error</a>)</pre>
			<p>
Errorf is a wrapper for fmt.Errorf that treats each argument as if it were
passed with a default Formatter interface returned by NewFormatter.  It
returns the formatted string as a value that satisfies error.  See
NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Errorf(format, spew.NewFormatter(a), spew.NewFormatter(b))
</pre>

			
			

		
			
			
			<h2 id="Fdump">func <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/dump.go?s=12407:12448#L462">Fdump</a>
				<a class="permalink" href="index.html#Fdump">&#xb6;</a>
				
				
			</h2>
			<pre>func Fdump(w <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Writer">Writer</a>, a ...interface{})</pre>
			<p>
Fdump formats and displays the passed arguments to io.Writer w.  It formats
exactly the same as Dump.
</p>

			
			

		
			
			
			<h2 id="Fprint">func <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/spew.go?s=1726:1787#L34">Fprint</a>
				<a class="permalink" href="index.html#Fprint">&#xb6;</a>
				
				
			</h2>
			<pre>func Fprint(w <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Writer">Writer</a>, a ...interface{}) (n <a href="../../../../builtin/index.html#int">int</a>, err <a href="../../../../builtin/index.html#error">error</a>)</pre>
			<p>
Fprint is a wrapper for fmt.Fprint that treats each argument as if it were
passed with a default Formatter interface returned by NewFormatter.  It
returns the number of bytes written and any write error encountered.  See
NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Fprint(w, spew.NewFormatter(a), spew.NewFormatter(b))
</pre>

			
			

		
			
			
			<h2 id="Fprintf">func <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/spew.go?s=2238:2315#L46">Fprintf</a>
				<a class="permalink" href="index.html#Fprintf">&#xb6;</a>
				
				
			</h2>
			<pre>func Fprintf(w <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Writer">Writer</a>, format <a href="../../../../builtin/index.html#string">string</a>, a ...interface{}) (n <a href="../../../../builtin/index.html#int">int</a>, err <a href="../../../../builtin/index.html#error">error</a>)</pre>
			<p>
Fprintf is a wrapper for fmt.Fprintf that treats each argument as if it were
passed with a default Formatter interface returned by NewFormatter.  It
returns the number of bytes written and any write error encountered.  See
NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Fprintf(w, format, spew.NewFormatter(a), spew.NewFormatter(b))
</pre>

			
			

		
			
			
			<h2 id="Fprintln">func <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/spew.go?s=2689:2752#L57">Fprintln</a>
				<a class="permalink" href="index.html#Fprintln">&#xb6;</a>
				
				
			</h2>
			<pre>func Fprintln(w <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Writer">Writer</a>, a ...interface{}) (n <a href="../../../../builtin/index.html#int">int</a>, err <a href="../../../../builtin/index.html#error">error</a>)</pre>
			<p>
Fprintln is a wrapper for fmt.Fprintln that treats each argument as if it
passed with a default Formatter interface returned by NewFormatter.  See
NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Fprintln(w, spew.NewFormatter(a), spew.NewFormatter(b))
</pre>

			
			

		
			
			
			<h2 id="NewFormatter">func <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/format.go?s=11230:11276#L407">NewFormatter</a>
				<a class="permalink" href="index.html#NewFormatter">&#xb6;</a>
				
				
			</h2>
			<pre>func NewFormatter(v interface{}) <a href="../../../../fmt/index.html">fmt</a>.<a href="../../../../fmt/index.html#Formatter">Formatter</a></pre>
			<p>
NewFormatter returns a custom formatter that satisfies the fmt.Formatter
interface.  As a result, it integrates cleanly with standard fmt package
printing functions.  The formatter is useful for inline printing of smaller data
types similar to the standard %v format specifier.
</p>
<p>
The custom formatter only responds to the %v (most compact), %+v (adds pointer
addresses), %#v (adds types), or %#+v (adds types and pointer addresses) verb
combinations.  Any other verbs such as %x and %q will be sent to the the
standard fmt package for formatting.  In addition, the custom formatter ignores
the width and precision arguments (however they will still work on the format
specifiers not handled by the custom formatter).
</p>
<p>
Typically this function shouldn&#39;t be called directly.  It is much easier to make
use of the custom formatter by calling one of the convenience functions such as
Printf, Println, or Fprintf.
</p>

			
			

		
			
			
			<h2 id="Print">func <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/spew.go?s=3188:3235#L69">Print</a>
				<a class="permalink" href="index.html#Print">&#xb6;</a>
				
				
			</h2>
			<pre>func Print(a ...interface{}) (n <a href="../../../../builtin/index.html#int">int</a>, err <a href="../../../../builtin/index.html#error">error</a>)</pre>
			<p>
Print is a wrapper for fmt.Print that treats each argument as if it were
passed with a default Formatter interface returned by NewFormatter.  It
returns the number of bytes written and any write error encountered.  See
NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Print(spew.NewFormatter(a), spew.NewFormatter(b))
</pre>

			
			

		
			
			
			<h2 id="Printf">func <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/spew.go?s=3676:3739#L81">Printf</a>
				<a class="permalink" href="index.html#Printf">&#xb6;</a>
				
				
			</h2>
			<pre>func Printf(format <a href="../../../../builtin/index.html#string">string</a>, a ...interface{}) (n <a href="../../../../builtin/index.html#int">int</a>, err <a href="../../../../builtin/index.html#error">error</a>)</pre>
			<p>
Printf is a wrapper for fmt.Printf that treats each argument as if it were
passed with a default Formatter interface returned by NewFormatter.  It
returns the number of bytes written and any write error encountered.  See
NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Printf(format, spew.NewFormatter(a), spew.NewFormatter(b))
</pre>

			<div id="example_Printf" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		<p>This example demonstrates how to use Printf to display a variable with a
format string and inline formatting.
</p>
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Create a double pointer to a uint 8.</span>
ui8 := uint8(5)
pui8 := &amp;ui8
ppui8 := &amp;pui8

<span class="comment">// Create a circular data type.</span>
type circular struct {
    ui8 uint8
    c   *circular
}
c := circular{ui8: 1}
c.c = &amp;c

<span class="comment">// Print!</span>
spew.Printf(&#34;ppui8: %v\n&#34;, ppui8)
spew.Printf(&#34;circular: %v\n&#34;, c)

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">ppui8: &lt;**&gt;5
circular: {1 &lt;*&gt;{1 &lt;*&gt;&lt;shown&gt;}}
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Println">func <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/spew.go?s=4184:4233#L93">Println</a>
				<a class="permalink" href="index.html#Println">&#xb6;</a>
				
				
			</h2>
			<pre>func Println(a ...interface{}) (n <a href="../../../../builtin/index.html#int">int</a>, err <a href="../../../../builtin/index.html#error">error</a>)</pre>
			<p>
Println is a wrapper for fmt.Println that treats each argument as if it were
passed with a default Formatter interface returned by NewFormatter.  It
returns the number of bytes written and any write error encountered.  See
NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Println(spew.NewFormatter(a), spew.NewFormatter(b))
</pre>

			
			

		
			
			
			<h2 id="Sdump">func <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/dump.go?s=12570:12605#L468">Sdump</a>
				<a class="permalink" href="index.html#Sdump">&#xb6;</a>
				
				
			</h2>
			<pre>func Sdump(a ...interface{}) <a href="../../../../builtin/index.html#string">string</a></pre>
			<p>
Sdump returns a string with the passed arguments formatted exactly the same
as Dump.
</p>

			
			

		
			
			
			<h2 id="Sprint">func <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/spew.go?s=4626:4662#L104">Sprint</a>
				<a class="permalink" href="index.html#Sprint">&#xb6;</a>
				
				
			</h2>
			<pre>func Sprint(a ...interface{}) <a href="../../../../builtin/index.html#string">string</a></pre>
			<p>
Sprint is a wrapper for fmt.Sprint that treats each argument as if it were
passed with a default Formatter interface returned by NewFormatter.  It
returns the resulting string.  See NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Sprint(spew.NewFormatter(a), spew.NewFormatter(b))
</pre>

			
			

		
			
			
			<h2 id="Sprintf">func <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/spew.go?s=5065:5117#L115">Sprintf</a>
				<a class="permalink" href="index.html#Sprintf">&#xb6;</a>
				
				
			</h2>
			<pre>func Sprintf(format <a href="../../../../builtin/index.html#string">string</a>, a ...interface{}) <a href="../../../../builtin/index.html#string">string</a></pre>
			<p>
Sprintf is a wrapper for fmt.Sprintf that treats each argument as if it were
passed with a default Formatter interface returned by NewFormatter.  It
returns the resulting string.  See NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Sprintf(format, spew.NewFormatter(a), spew.NewFormatter(b))
</pre>

			
			

		
			
			
			<h2 id="Sprintln">func <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/spew.go?s=5524:5562#L126">Sprintln</a>
				<a class="permalink" href="index.html#Sprintln">&#xb6;</a>
				
				
			</h2>
			<pre>func Sprintln(a ...interface{}) <a href="../../../../builtin/index.html#string">string</a></pre>
			<p>
Sprintln is a wrapper for fmt.Sprintln that treats each argument as if it
were passed with a default Formatter interface returned by NewFormatter.  It
returns the resulting string.  See NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Sprintln(spew.NewFormatter(a), spew.NewFormatter(b))
</pre>

			
			

		
		
			
			
			<h2 id="ConfigState">type <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go?s=1435:4562#L27">ConfigState</a>
				<a class="permalink" href="index.html#ConfigState">&#xb6;</a>
				
				
			</h2>
			<p>
ConfigState houses the configuration options used by spew to format and
display values.  There is a global instance, Config, that is used to control
all top-level Formatter and Dump functionality.  Each ConfigState instance
provides methods equivalent to the top-level functions.
</p>
<p>
The zero value for ConfigState provides no indentation.  You would typically
want to set it to a space or a tab.
</p>
<p>
Alternatively, you can use NewDefaultConfig to get a ConfigState instance
with default settings.  See the documentation of NewDefaultConfig for default
values.
</p>

			<pre>type ConfigState struct {
<span id="ConfigState.Indent"></span>    <span class="comment">// Indent specifies the string to use for each indentation level.  The</span>
    <span class="comment">// global config instance that all top-level functions use set this to a</span>
    <span class="comment">// single space by default.  If you would like more indentation, you might</span>
    <span class="comment">// set this to a tab with &#34;\t&#34; or perhaps two spaces with &#34;  &#34;.</span>
    Indent <a href="../../../../builtin/index.html#string">string</a>

<span id="ConfigState.MaxDepth"></span>    <span class="comment">// MaxDepth controls the maximum number of levels to descend into nested</span>
    <span class="comment">// data structures.  The default, 0, means there is no limit.</span>
    <span class="comment">//</span>
    <span class="comment">// NOTE: Circular data structures are properly detected, so it is not</span>
    <span class="comment">// necessary to set this value unless you specifically want to limit deeply</span>
    <span class="comment">// nested data structures.</span>
    MaxDepth <a href="../../../../builtin/index.html#int">int</a>

<span id="ConfigState.DisableMethods"></span>    <span class="comment">// DisableMethods specifies whether or not error and Stringer interfaces are</span>
    <span class="comment">// invoked for types that implement them.</span>
    DisableMethods <a href="../../../../builtin/index.html#bool">bool</a>

<span id="ConfigState.DisablePointerMethods"></span>    <span class="comment">// DisablePointerMethods specifies whether or not to check for and invoke</span>
    <span class="comment">// error and Stringer interfaces on types which only accept a pointer</span>
    <span class="comment">// receiver when the current type is not a pointer.</span>
    <span class="comment">//</span>
    <span class="comment">// NOTE: This might be an unsafe action since calling one of these methods</span>
    <span class="comment">// with a pointer receiver could technically mutate the value, however,</span>
    <span class="comment">// in practice, types which choose to satisify an error or Stringer</span>
    <span class="comment">// interface with a pointer receiver should not be mutating their state</span>
    <span class="comment">// inside these interface methods.  As a result, this option relies on</span>
    <span class="comment">// access to the unsafe package, so it will not have any effect when</span>
    <span class="comment">// running in environments without access to the unsafe package such as</span>
    <span class="comment">// Google App Engine or with the &#34;safe&#34; build tag specified.</span>
    DisablePointerMethods <a href="../../../../builtin/index.html#bool">bool</a>

<span id="ConfigState.DisablePointerAddresses"></span>    <span class="comment">// DisablePointerAddresses specifies whether to disable the printing of</span>
    <span class="comment">// pointer addresses. This is useful when diffing data structures in tests.</span>
    DisablePointerAddresses <a href="../../../../builtin/index.html#bool">bool</a>

<span id="ConfigState.DisableCapacities"></span>    <span class="comment">// DisableCapacities specifies whether to disable the printing of capacities</span>
    <span class="comment">// for arrays, slices, maps and channels. This is useful when diffing</span>
    <span class="comment">// data structures in tests.</span>
    DisableCapacities <a href="../../../../builtin/index.html#bool">bool</a>

<span id="ConfigState.ContinueOnMethod"></span>    <span class="comment">// ContinueOnMethod specifies whether or not recursion should continue once</span>
    <span class="comment">// a custom error or Stringer interface is invoked.  The default, false,</span>
    <span class="comment">// means it will print the results of invoking the custom error or Stringer</span>
    <span class="comment">// interface and return immediately instead of continuing to recurse into</span>
    <span class="comment">// the internals of the data type.</span>
    <span class="comment">//</span>
    <span class="comment">// NOTE: This flag does not have any effect if method invocation is disabled</span>
    <span class="comment">// via the DisableMethods or DisablePointerMethods options.</span>
    ContinueOnMethod <a href="../../../../builtin/index.html#bool">bool</a>

<span id="ConfigState.SortKeys"></span>    <span class="comment">// SortKeys specifies map keys should be sorted before being printed. Use</span>
    <span class="comment">// this to have a more deterministic, diffable output.  Note that only</span>
    <span class="comment">// native types (bool, int, uint, floats, uintptr and string) and types</span>
    <span class="comment">// that support the error or Stringer interfaces (if methods are</span>
    <span class="comment">// enabled) are supported, with other types sorted according to the</span>
    <span class="comment">// reflect.Value.String() output which guarantees display stability.</span>
    SortKeys <a href="../../../../builtin/index.html#bool">bool</a>

<span id="ConfigState.SpewKeys"></span>    <span class="comment">// SpewKeys specifies that, as a last resort attempt, map keys should</span>
    <span class="comment">// be spewed to strings and sorted by those strings.  This is only</span>
    <span class="comment">// considered if SortKeys is true.</span>
    SpewKeys <a href="../../../../builtin/index.html#bool">bool</a>
}
</pre>

			

			

			<div id="example_ConfigState" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		<p>This example demonstrates how to use a ConfigState.
</p>
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Modify the indent level of the ConfigState only.  The global</span>
<span class="comment">// configuration is not modified.</span>
scs := spew.ConfigState{Indent: &#34;\t&#34;}

<span class="comment">// Output using the ConfigState instance.</span>
v := map[string]int{&#34;one&#34;: 1}
scs.Printf(&#34;v: %v\n&#34;, v)
scs.Dump(v)

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">v: map[one:1]
(map[string]int) (len=1) {
	(string) (len=3) &#34;one&#34;: (int) 1
}
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewDefaultConfig">func <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go?s=12767:12803#L294">NewDefaultConfig</a>
					<a class="permalink" href="index.html#NewDefaultConfig">&#xb6;</a>
					
					
				</h3>
				<pre>func NewDefaultConfig() *<a href="index.html#ConfigState">ConfigState</a></pre>
				<p>
NewDefaultConfig returns a ConfigState with the following default settings.
</p>
<pre>Indent: &#34; &#34;
MaxDepth: 0
DisableMethods: false
DisablePointerMethods: false
ContinueOnMethod: false
SortKeys: false
</pre>

				
				
			

			
				
				<h3 id="ConfigState.Dump">func (*ConfigState) <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go?s=11838:11882#L263">Dump</a>
					<a class="permalink" href="index.html#ConfigState.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#ConfigState">ConfigState</a>) Dump(a ...interface{})</pre>
				<p>
Dump displays the passed parameters to standard out with newlines, customizable
indentation, and additional debug information such as complete types and all
pointer addresses used to indirect to the final value.  It provides the
following features over the built-in printing facilities provided by the fmt
package:
</p>
<pre>* Pointers are dereferenced and followed
* Circular data structures are detected and handled properly
* Custom Stringer/error interfaces are optionally invoked, including
  on unexported types
* Custom types which only implement the Stringer/error interfaces via
  a pointer receiver are optionally invoked when passing non-pointer
  variables
* Byte arrays and slices are dumped like the hexdump -C command which
  includes offsets, byte values in hex, and ASCII output
</pre>
<p>
The configuration options are controlled by modifying the public members
of c.  See ConfigState for options documentation.
</p>
<p>
See Fdump if you would prefer dumping to an arbitrary io.Writer or Sdump to
get the formatted result as a string.
</p>

				
				<div id="example_ConfigState_Dump" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		<p>This example demonstrates how to use ConfigState.Dump to dump variables to
stdout
</p>
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// See the top-level Dump example for details on the types used in this</span>
<span class="comment">// example.</span>

<span class="comment">// Create two ConfigState instances with different indentation.</span>
scs := spew.ConfigState{Indent: &#34;\t&#34;}
scs2 := spew.ConfigState{Indent: &#34; &#34;}

<span class="comment">// Setup some sample data structures for the example.</span>
bar := Bar{uintptr(0)}
s1 := Foo{bar, map[interface{}]interface{}{&#34;one&#34;: true}}

<span class="comment">// Dump using the ConfigState instances.</span>
scs.Dump(s1)
scs2.Dump(s1)

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">(spew_test.Foo) {
	unexportedField: (spew_test.Bar) {
		data: (uintptr) &lt;nil&gt;
	},
	ExportedField: (map[interface {}]interface {}) (len=1) {
		(string) (len=3) &#34;one&#34;: (bool) true
	}
}
(spew_test.Foo) {
 unexportedField: (spew_test.Bar) {
  data: (uintptr) &lt;nil&gt;
 },
 ExportedField: (map[interface {}]interface {}) (len=1) {
  (string) (len=3) &#34;one&#34;: (bool) true
 }
}
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="ConfigState.Errorf">func (*ConfigState) <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go?s=5126:5199#L105">Errorf</a>
					<a class="permalink" href="index.html#ConfigState.Errorf">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#ConfigState">ConfigState</a>) Errorf(format <a href="../../../../builtin/index.html#string">string</a>, a ...interface{}) (err <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>
Errorf is a wrapper for fmt.Errorf that treats each argument as if it were
passed with a Formatter interface returned by c.NewFormatter.  It returns
the formatted string as a value that satisfies error.  See NewFormatter
for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Errorf(format, c.NewFormatter(a), c.NewFormatter(b))
</pre>

				
				
				
			
				
				<h3 id="ConfigState.Fdump">func (*ConfigState) <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go?s=10714:10772#L236">Fdump</a>
					<a class="permalink" href="index.html#ConfigState.Fdump">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#ConfigState">ConfigState</a>) Fdump(w <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Writer">Writer</a>, a ...interface{})</pre>
				<p>
Fdump formats and displays the passed arguments to io.Writer w.  It formats
exactly the same as Dump.
</p>

				
				
				
			
				
				<h3 id="ConfigState.Fprint">func (*ConfigState) <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go?s=5634:5712#L117">Fprint</a>
					<a class="permalink" href="index.html#ConfigState.Fprint">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#ConfigState">ConfigState</a>) Fprint(w <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Writer">Writer</a>, a ...interface{}) (n <a href="../../../../builtin/index.html#int">int</a>, err <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>
Fprint is a wrapper for fmt.Fprint that treats each argument as if it were
passed with a Formatter interface returned by c.NewFormatter.  It returns
the number of bytes written and any write error encountered.  See
NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Fprint(w, c.NewFormatter(a), c.NewFormatter(b))
</pre>

				
				
				
			
				
				<h3 id="ConfigState.Fprintf">func (*ConfigState) <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go?s=6153:6247#L129">Fprintf</a>
					<a class="permalink" href="index.html#ConfigState.Fprintf">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#ConfigState">ConfigState</a>) Fprintf(w <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Writer">Writer</a>, format <a href="../../../../builtin/index.html#string">string</a>, a ...interface{}) (n <a href="../../../../builtin/index.html#int">int</a>, err <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>
Fprintf is a wrapper for fmt.Fprintf that treats each argument as if it were
passed with a Formatter interface returned by c.NewFormatter.  It returns
the number of bytes written and any write error encountered.  See
NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Fprintf(w, format, c.NewFormatter(a), c.NewFormatter(b))
</pre>

				
				
				
			
				
				<h3 id="ConfigState.Fprintln">func (*ConfigState) <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go?s=6611:6691#L140">Fprintln</a>
					<a class="permalink" href="index.html#ConfigState.Fprintln">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#ConfigState">ConfigState</a>) Fprintln(w <a href="../../../../io/index.html">io</a>.<a href="../../../../io/index.html#Writer">Writer</a>, a ...interface{}) (n <a href="../../../../builtin/index.html#int">int</a>, err <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>
Fprintln is a wrapper for fmt.Fprintln that treats each argument as if it
passed with a Formatter interface returned by c.NewFormatter.  See
NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Fprintln(w, c.NewFormatter(a), c.NewFormatter(b))
</pre>

				
				
				
			
				
				<h3 id="ConfigState.NewFormatter">func (*ConfigState) <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go?s=10510:10573#L230">NewFormatter</a>
					<a class="permalink" href="index.html#ConfigState.NewFormatter">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#ConfigState">ConfigState</a>) NewFormatter(v interface{}) <a href="../../../../fmt/index.html">fmt</a>.<a href="../../../../fmt/index.html#Formatter">Formatter</a></pre>
				<p>
NewFormatter returns a custom formatter that satisfies the fmt.Formatter
interface.  As a result, it integrates cleanly with standard fmt package
printing functions.  The formatter is useful for inline printing of smaller data
types similar to the standard %v format specifier.
</p>
<p>
The custom formatter only responds to the %v (most compact), %+v (adds pointer
addresses), %#v (adds types), and %#+v (adds types and pointer addresses) verb
combinations.  Any other verbs such as %x and %q will be sent to the the
standard fmt package for formatting.  In addition, the custom formatter ignores
the width and precision arguments (however they will still work on the format
specifiers not handled by the custom formatter).
</p>
<p>
Typically this function shouldn&#39;t be called directly.  It is much easier to make
use of the custom formatter by calling one of the convenience functions such as
c.Printf, c.Println, or c.Printf.
</p>

				
				
				
			
				
				<h3 id="ConfigState.Print">func (*ConfigState) <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go?s=7117:7181#L152">Print</a>
					<a class="permalink" href="index.html#ConfigState.Print">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#ConfigState">ConfigState</a>) Print(a ...interface{}) (n <a href="../../../../builtin/index.html#int">int</a>, err <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>
Print is a wrapper for fmt.Print that treats each argument as if it were
passed with a Formatter interface returned by c.NewFormatter.  It returns
the number of bytes written and any write error encountered.  See
NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Print(c.NewFormatter(a), c.NewFormatter(b))
</pre>

				
				
				
			
				
				<h3 id="ConfigState.Printf">func (*ConfigState) <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go?s=7612:7692#L164">Printf</a>
					<a class="permalink" href="index.html#ConfigState.Printf">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#ConfigState">ConfigState</a>) Printf(format <a href="../../../../builtin/index.html#string">string</a>, a ...interface{}) (n <a href="../../../../builtin/index.html#int">int</a>, err <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>
Printf is a wrapper for fmt.Printf that treats each argument as if it were
passed with a Formatter interface returned by c.NewFormatter.  It returns
the number of bytes written and any write error encountered.  See
NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Printf(format, c.NewFormatter(a), c.NewFormatter(b))
</pre>

				
				<div id="example_ConfigState_Printf" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		<p>This example demonstrates how to use ConfigState.Printf to display a variable
with a format string and inline formatting.
</p>
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// See the top-level Dump example for details on the types used in this</span>
<span class="comment">// example.</span>

<span class="comment">// Create two ConfigState instances and modify the method handling of the</span>
<span class="comment">// first ConfigState only.</span>
scs := spew.NewDefaultConfig()
scs2 := spew.NewDefaultConfig()
scs.DisableMethods = true

<span class="comment">// Alternatively</span>
<span class="comment">// scs := spew.ConfigState{Indent: &#34; &#34;, DisableMethods: true}</span>
<span class="comment">// scs2 := spew.ConfigState{Indent: &#34; &#34;}</span>

<span class="comment">// This is of type Flag which implements a Stringer and has raw value 1.</span>
f := flagTwo

<span class="comment">// Dump using the ConfigState instances.</span>
scs.Printf(&#34;f: %v\n&#34;, f)
scs2.Printf(&#34;f: %v\n&#34;, f)

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">f: 1
f: flagTwo
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="ConfigState.Println">func (*ConfigState) <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go?s=8127:8193#L176">Println</a>
					<a class="permalink" href="index.html#ConfigState.Println">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#ConfigState">ConfigState</a>) Println(a ...interface{}) (n <a href="../../../../builtin/index.html#int">int</a>, err <a href="../../../../builtin/index.html#error">error</a>)</pre>
				<p>
Println is a wrapper for fmt.Println that treats each argument as if it were
passed with a Formatter interface returned by c.NewFormatter.  It returns
the number of bytes written and any write error encountered.  See
NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Println(c.NewFormatter(a), c.NewFormatter(b))
</pre>

				
				
				
			
				
				<h3 id="ConfigState.Sdump">func (*ConfigState) <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go?s=12006:12058#L269">Sdump</a>
					<a class="permalink" href="index.html#ConfigState.Sdump">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#ConfigState">ConfigState</a>) Sdump(a ...interface{}) <a href="../../../../builtin/index.html#string">string</a></pre>
				<p>
Sdump returns a string with the passed arguments formatted exactly the same
as Dump.
</p>

				
				
				
			
				
				<h3 id="ConfigState.Sprint">func (*ConfigState) <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go?s=8576:8629#L187">Sprint</a>
					<a class="permalink" href="index.html#ConfigState.Sprint">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#ConfigState">ConfigState</a>) Sprint(a ...interface{}) <a href="../../../../builtin/index.html#string">string</a></pre>
				<p>
Sprint is a wrapper for fmt.Sprint that treats each argument as if it were
passed with a Formatter interface returned by c.NewFormatter.  It returns
the resulting string.  See NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Sprint(c.NewFormatter(a), c.NewFormatter(b))
</pre>

				
				
				
			
				
				<h3 id="ConfigState.Sprintf">func (*ConfigState) <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go?s=9022:9091#L198">Sprintf</a>
					<a class="permalink" href="index.html#ConfigState.Sprintf">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#ConfigState">ConfigState</a>) Sprintf(format <a href="../../../../builtin/index.html#string">string</a>, a ...interface{}) <a href="../../../../builtin/index.html#string">string</a></pre>
				<p>
Sprintf is a wrapper for fmt.Sprintf that treats each argument as if it were
passed with a Formatter interface returned by c.NewFormatter.  It returns
the resulting string.  See NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Sprintf(format, c.NewFormatter(a), c.NewFormatter(b))
</pre>

				
				
				
			
				
				<h3 id="ConfigState.Sprintln">func (*ConfigState) <a href="http://localhost:8080/src/github.com/davecgh/go-spew/spew/config.go?s=9488:9543#L209">Sprintln</a>
					<a class="permalink" href="index.html#ConfigState.Sprintln">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="index.html#ConfigState">ConfigState</a>) Sprintln(a ...interface{}) <a href="../../../../builtin/index.html#string">string</a></pre>
				<p>
Sprintln is a wrapper for fmt.Sprintln that treats each argument as if it
were passed with a Formatter interface returned by c.NewFormatter.  It
returns the resulting string.  See NewFormatter for formatting details.
</p>
<p>
This function is shorthand for the following syntax:
</p>
<pre>fmt.Sprintln(c.NewFormatter(a), c.NewFormatter(b))
</pre>

				
				
				
			
		
	

	







<div id="footer">
Build version go1.18.4.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="../../../../../LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
